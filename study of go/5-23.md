2022/5/23



动态查找树主要有：
二叉查找树（Binary Search Tree），
平衡二叉查找树（Balanced Binary Search Tree），
红黑树(Red-Black Tree )，B-tree/B+-tree/ B*-tree (B~Tree)

前三者是典型的二叉查找树结构，其查找的时间复杂度O(log2N)与树的深度相关，那么降低树的深度自然会提高查找效率。



在大规模数据存储中进行索引查询，树节点存储的元素数量是有限的，**二叉树结构由于深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下**，那么如何减少树的深度，一个基本的想法就是：**采用多叉树结构**（由于树节点元素数量是有限的，自然该节点的子树数量也就是有限的）。

于是提出了一个新的查找树结构——多路查找树。根据平衡二叉树的启发，自然就想到平衡多路查找树结构B-tree，即B树结构(**B树的各种操作能使B树保持较低的高度，从而达到有效避免磁盘过于频繁的查找存取操作，从而有效提高查找效率**)



###### 性质

1. （root top）根结点关键字满足1<=k <= m - 1。

2. 每个非根节点所包含的关键字个数k满足：

   Math.ceil(m/2)-1 <=k <= m - 1（占有效率在50%以上）；

3. 指针数=分支数=关键字+1，故分支数量c满足：Math.ceil(m/2) <= c <= m ；

4. 每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。

5. 所有的叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。



###### 插入

通过搜索找到对应的结点进行插入

- 该结点的关键字<m-1个，直接插入即可；

- 该结点的关键字=m-1个，根据B树的性质显然无法满足，需要将其裂。

  分裂是该结点分成两半，将中间的关键字提升到父亲结点中，若父亲结点也满员，则需要再向上进行回溯，甚至需要对根结点进行分裂，这时整棵树都加了一层。

![img](https://pic4.zhimg.com/80/v2-deab5cfdde93804d94ec98a18edd40fb_720w.jpg)

![img](https://pic3.zhimg.com/80/v2-cb52d61ef792f21ae2e6eb5cd99cf8c2_720w.jpg)

![img](https://pic3.zhimg.com/80/v2-b9c8d6de9e12b640a9afeccbed5193ca_720w.jpg)



###### 删除

同样需要搜索找到相应的值，存在则进行删除，需要考虑删除之后的情况

- 若删除后依然满足B树性质，则不做任何处理；
- 若删除后不满足B树的性质（关键字没有到达ceil(m/2)-1（占有率50%以下）），则需要向兄弟结点借关键字，
  + 若兄弟结点的关键字足够借给该结点，则过程为将父亲结点的关键字下移，兄弟结点的关键字上移；
  + 若借出去以后也无法满足性质，即之前兄弟结点的关键字的数量为ceil(m/2)-1，借的一方的关键字数量为ceil(m/2)-2的情况，那么我们可以将该结点合并到兄弟结点中，合并之后的子结点数量少了一个，则需要将父亲结点的关键字下放，如果父亲结点不满足性质（1<=k <= m - 1），则向上回溯；



## B+树

由于B+树的数据都存储在**叶结点**中，**分支结点为索引**，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引。

B+树与B树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶结点中。



###### 性质

1. 根结点（root top）只有一个，关键字数量范围为[1，m-1]；
2. 除根结点，内部结点关键字的数量范围为[ceil(m/2)-1, m-1]，关键字顺序递增；
3. 指针数=分支数=关键字数+1，每个结点包含分支数范围为[ceil(m/2), m]；
4. 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都**小于**它，右子树中的key都**大于等于**它。
5. 所有叶子结点都在同一层，每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。



###### 操作

在增加值的时候，如果存在满员的情况，将选择结点中的值作为新的索引，加入到父节点，并且结点中的值不会因为作为了索引而减少，只是父结点关键字增多，会对子结点进行了拆分。



**B+树的插入操作**

1. 若为空树，创建一个叶子结点，然后将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。

2. 针对叶子类型结点：根据key值找到叶子结点，向这个叶子结点插入记录。

   + 插入后，若当前结点key的个数小于等于m-1，则插入结束。
   + 若大于等于m，将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前m/2个记录，右结点包含剩下的记录，将第m/2+1个记录的key进位到父结点中（父结点一定是索引类型结点），进位到父结点的key左孩子指针向左结点,右孩子指针向右结点。将当前结点的指针指向父结点，然后执行第3步。

3. 针对索引类型结点：若当前结点key的个数小于等于m-1，则插入结束。

   否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前(m-1)/2个key，右结点包含m-(m-1)/2个key，将第m/2个key进位到父结点中，进位到父结点的key左孩子指向左结点, 进位到父结点的key右孩子指向右结点。将当前结点的指针指向父结点，然后重复第3步。

   

![img](https://pic2.zhimg.com/80/v2-a296f0635713266d1a7205222c349509_720w.png)



![img](https://pic2.zhimg.com/80/v2-d05b047cd649de5a1f3f2a778d8023ed_720w.png)



![img](https://pic2.zhimg.com/80/v2-4f194efd7f989912f5c42d5f857ca975_720w.jpg)



![img](https://pic4.zhimg.com/80/v2-fd4bdb89922885bd4debd354486eb9ff_720w.jpg)



![img](https://pic4.zhimg.com/80/v2-1b65801db999aca24e248cfc89edb417_720w.jpg)



![preview](https://pic4.zhimg.com/v2-cc654a280e10e4f5cc64dd5ad1475507_r.jpg)



![img](https://pic2.zhimg.com/80/v2-651a7312bb3b2912755c2d276fe6aad9_720w.png)



![img](https://pic2.zhimg.com/80/v2-562495d82dddaeb62f5e83b735f15309_720w.jpg)



**B+树的删除操作**

_注意_：如果叶子结点中没有相应的key，则删除失败

1. 删除叶子结点中对应的key。删除后若结点的key的个数大于等于Math.ceil(m-1)/2 – 1（满足B+树性质），删除操作结束,否则执行第2步。
2. 若兄弟结点key有富余（大于Math.ceil(m-1)/2 – 1），向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。
3. 若兄弟结点中没有富余的key,则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key（父结点中的这个key两边的孩子指针就变成了一个指针，正好指向这个新的叶子结点），将当前结点指向父结点（必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。

4）若索引结点的key的个数大于等于Math.ceil(m-1)/2 – 1，则删除操作结束。否则执行第5步

5）若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步

6）当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。



初始状态

![img](https://pic3.zhimg.com/80/v2-a253637b1975e85cf62d8fd004ebb8ae_720w.jpg)

删除22，而后叶子结点中key的个数大于等于2，删除结束

![img](https://pic4.zhimg.com/80/v2-7d2a3dc4f803bbf0e500657c6c5207b3_720w.jpg)

删除15，当前结点只有一个key（10）,不满足条件，而兄弟结点有三个key（7，8，9），可以从兄弟结点借一个关键字为9的记录,同时更新将父结点中的关键字由10也变为9，删除结束。

![img](https://pic3.zhimg.com/80/v2-acf51ab3923bb4848278b453d6d4082e_720w.jpg)

删除7

![img](https://pic2.zhimg.com/80/v2-7f329a7438e79f1ad923278c8adf15f1_720w.jpg)

当前结点关键字个数小于m/2（2），（左）兄弟结点中的也没有富余的关键字，所以当前结点和兄弟结点合并，并**删除父结点中的key**，当前结点指向父结点。

![img](https://pic1.zhimg.com/80/v2-3c072701f7a695cba38ec1d18821d990_720w.jpg)

此时当前结点的关键字个数小于m/2（2），兄弟结点的关键字也没有富余，所以父结点中的关键字下移，和两个（左右）孩子结点合并，结果如下图所示。

![img](https://pic4.zhimg.com/80/v2-50c94c13288ce24ad9d220289686240b_720w.png)



###### **B树和B+树的区别**

都是由于B+树和B不同的存储结构引起的差别。

1. 关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。

2. 存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据即为完整的数据，但是B树的数据存储在每一个结点加上所有叶子结点数据即完整。

3. 分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和children的指针（指针是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。

4. 查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。

   

根据B+树的结构，B+树在文件系统，数据库系统当中更有优势，原因如下：

1. B+树的磁盘读写代价更低
   B+树的内部结点并没有指向关键字具体信息的**指针**。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中。**一次性读入内存中的需要查找的关键字也就越多**。相对来说I/O读写次数也就降低了。
2. B+树的查询效率更加稳定
   由于内部结点只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。**所有关键字查询的路径长度相同**，所以每一个数据的查询效率相当。
3. B+树更有利于对数据库的扫描
   B树在提高了磁盘IO性能，但没有解决元素遍历的效率低下问题，而B+树**只需要遍历叶子节点即可完成全部关键字信息的扫描**，所以对于数据库中频繁使用的range query，B+树有着更高的性能。